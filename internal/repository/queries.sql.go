// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPlot = `-- name: AddPlot :exec
INSERT INTO plots (user_id, name, content)
VALUES ($1::INT, $2::TEXT, $3)
`

type AddPlotParams struct {
	UserID  int32
	Name    string
	Content []byte
}

func (q *Queries) AddPlot(ctx context.Context, arg AddPlotParams) error {
	_, err := q.db.Exec(ctx, addPlot, arg.UserID, arg.Name, arg.Content)
	return err
}

const addUserCredentials = `-- name: AddUserCredentials :one
INSERT INTO users_credentials (email, password)
VALUES ($1::TEXT, $2::TEXT)
RETURNING id
`

type AddUserCredentialsParams struct {
	UserEmail    string
	UserPassword string
}

func (q *Queries) AddUserCredentials(ctx context.Context, arg AddUserCredentialsParams) (int64, error) {
	row := q.db.QueryRow(ctx, addUserCredentials, arg.UserEmail, arg.UserPassword)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addUserInfo = `-- name: AddUserInfo :exec
INSERT INTO users_info (id, first_name, last_name, dateOfBirthday)
VALUES ($1::INT, $2::TEXT, $3::TEXT, $4::TIMESTAMP)
`

type AddUserInfoParams struct {
	ID            int32
	FirstName     string
	LastName      string
	Dateofbirhday pgtype.Timestamp
}

func (q *Queries) AddUserInfo(ctx context.Context, arg AddUserInfoParams) error {
	_, err := q.db.Exec(ctx, addUserInfo,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Dateofbirhday,
	)
	return err
}

const checkUserExists = `-- name: CheckUserExists :one
SELECT EXISTS(SELECT email FROM users_credentials WHERE email = $1::TEXT)
`

func (q *Queries) CheckUserExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getPlotsByIds = `-- name: GetPlotsByIds :many
SELECT id, user_id, name, content from plots
where id = any ($1::INT[])
`

func (q *Queries) GetPlotsByIds(ctx context.Context, plotIds []int32) ([]Plot, error) {
	rows, err := q.db.Query(ctx, getPlotsByIds, plotIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Plot
	for rows.Next() {
		var i Plot
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCredentials = `-- name: GetUserCredentials :one
SELECT password from users_credentials
where email = $1::TEXT
`

func (q *Queries) GetUserCredentials(ctx context.Context, email string) (string, error) {
	row := q.db.QueryRow(ctx, getUserCredentials, email)
	var password string
	err := row.Scan(&password)
	return password, err
}

const getUserPlotsInfo = `-- name: GetUserPlotsInfo :many
SELECT id, name from plots
where user_id = $1::INT
`

type GetUserPlotsInfoRow struct {
	ID   int64
	Name string
}

func (q *Queries) GetUserPlotsInfo(ctx context.Context, userID int32) ([]GetUserPlotsInfoRow, error) {
	rows, err := q.db.Query(ctx, getUserPlotsInfo, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPlotsInfoRow
	for rows.Next() {
		var i GetUserPlotsInfoRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
